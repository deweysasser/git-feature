#!/usr/bin/python2.7

# Purpose:  
# git feature start foo -> git checkout -b wip/foo
# git feature ready -> git branch ready/<featurename> or (git stash save "pub-checkpoint"; git 


import argparse
import subprocess
import re
import inspect
import sys
import functools

######################################################################
# Metaprogramming

Commands=[]
def command(func):
    Commands.append(func)
    return func

def quiet(func):
    @functools.wraps(func)
    def wrapped(*args, **kwargs):
        global Verbose
        Verbose=False
        return func(*args, **kwargs)
    return wrapped


def cache(obj):
    cache = obj.cache = {}

    @functools.wraps(obj)
    def memoizer(*args, **kwargs):
        if args not in cache:
            cache[args] = obj(*args, **kwargs)
        return cache[args]
    return memoizer

######################################################################
# Utilities
def error(message):
    print message
    sys.exit(1)



######################################################################
# Process utilities

class Pipe(object):
    def __init__(self, command):
        self.command = command

    def __enter__(self):
        self.process = subprocess.Popen(self.command.split(), stdout=subprocess.PIPE)
        return self.process.stdout

    def __exit__(self, type, value, tb):
        if self.process.wait() > 0:
            raise Exception("Error running command {}".format(self.command))

def run(command):
    if Verbose:
        print command
    if subprocess.call(command.split()) > 0:
        raise Exception("Error running git branch")


######################################################################
# basic GIT commands

def linesFrom(cmd):
    lines = []
    with Pipe(cmd) as p:
        return map(lambda x: x.strip(), p.readlines())

def cutlines(col,cmd):
    return map(lambda x: x[col:], linesFrom(cmd))

def oneline(cmd):
    with Pipe(cmd) as p:
        return p.readline().rstrip()

class GitBranch(object):
    def __init__(self, name):
        self.name = name

    def exists(self):
        return self.name in git.branches()

    def hasChanges(self, other):
        return len(self.changes(other)) > 0

    def changes(self, other):
        return git.changes(self.name, str(other))

    def commit(self):
        return git.commitFor(self.name)

    def base(self, other):
        return git.mergeBase(self.name, other)

    def checkout(self, *args):
        return git.checkout(self.name, *args)

    def delete(self):
        return git.branch("-D", self.name)

    def create(self, base=None):
        if base:
            git.branch(self.name, base)
        else:
            git.branch(self.name)

    def __str__(self):
        return self.name

class Git(object):
    def __init__(self):
        self.Config=None
        pass

    def __getattr__(self, cmd):
        ''' Default functions are "just run the equivalent GIT command"'''
        def command(*args):
            run("git {} {}".format(cmd, " ".join(map(str,args))))
        return command

    def currentBranch(self):
        return re.sub("^refs/heads/", "", oneline("git symbolic-ref HEAD"))

    @cache
    def commitFor(self, branch):
        return oneline("git rev-parse {}".format(branch))

    @cache
    def mergeBase(self, b1, b2):
        return oneline("git merge-base {} {}".format(b1, b2))
    
    @cache
    def branches(self, *args):
        return map(lambda x: re.sub("^\* ", "", x), linesFrom("git branch " + " ".join(args)))

    @cache
    def changes(self, b1, b2):
        base = self.mergeBase(b1, b2)
        if base == self.commitFor(b1):
            return []
        return linesFrom("git log --oneline {}..{}".format(base, b1))

    def remotes(self):
        return linesFrom("git remote")

    @cache
    def hasChanges(self, *args):
        if subprocess.call(("git diff --quiet " + " ".join(args)).split()) == 0:
            return False
        else:
            return True

    def modified(self):
        files=[]
        with Pipe("git ls-files --exclude-standard -m") as p:
            return map(lambda x: x.rsplit(), p.readlines())

    @cache
    def config(self, key, default=None):
        if self.Config is None:
            self.Config =dict()
            p= subprocess.Popen("git config -l".split(), stdout=subprocess.PIPE)
            for line in p.stdout.readlines():
                parts=line.rstrip().split("=", 1)
                self.Config[parts[0]]=parts[1]
                p.wait()
	
        if key in self.Config:
            return self.Config[key]
        else:
            return default

git=Git()


######################################################################
# git informational functions




######################################################################
# Advanced git operations

class stashed(object):
    def __init__(self):
        pass

    def __enter__(self):
        if len(git.modified())>0:
            self.stashed=True
            run("git stash save temp stash")
        else:
            self.stashed=False

    def __exit__(self, type, value, tb):
        if self.stashed:
            run("git stash pop")


class Checkout(object):
    def __init__(self, branch, quiet=False):
        self.saved = None
        self.branch = branch
        if quiet:
            self.quiet="-q"
        else:
            self.quiet = ""

        self.saved = git.currentBranch()
        git.checkout(self.quiet, self.branch)

    def __enter__(self):
        pass

    def __exit__(self, type, value, tb):
        if type is not None:
            git.merge("--abort")
        git.checkout(self.quiet, self.saved)

######################################################################
# git feature objects

class Feature(object):
    def __init__(self, string=None):
        if string is None: string = git.currentBranch()

        if not re.match("^(wip|ready|bugfix|feature)/",string):
            raise Exception("Branch {} is not a feature branch".format(string))
            
        self.name = re.sub("^(wip|ready)/", "", string)
        if self.name is None:
            self.name = string

    @cache
    def wip(self):
        return GitBranch("wip/{}".format(self.name))

    @cache
    def ready(self):
        return GitBranch("ready/{}".format(self.name))

    def __str__(self):
        return self.name

def uniq(list):
    d = {}
    def seen(x):
        r = d.get(x, False)
        d[x] = True
        return r

    return [x for x in list if not seen(x)]

def features(*args):
    return map(Feature,
               uniq(map(lambda x: re.sub("^(\* )?(wip|ready)/", "", x), 
                   filter(lambda x: re.match("^(\* )?(wip|ready)/", x),
                               git.branches(*args)))))

            


######################################################################
# git feature commands


@command
def start(name, base=False):
    '''Start a feature called NAME'''

    target = Feature(name).wip()
    integration = git.config("feature.target", "master")

    if git.currentBranch() == str(target):
        print "Already on {}".format(target)
        return

    if target.exists():
        target.checkout()
    else:
        if base:
            target.create(integration)
        else:
            target.create()
        target.checkout()

@command
def rebase():
    '''Rebase the current WIP changes so that they do not interfere with publishing ready changes'''
    current = git.currentBranch()
    with stashed():
        target = re.sub("^wip/", "ready/", current)
        base = git.mergeBase(current, target)
        git.rebase("-i", base)

@command
def log():
    '''Rebase the current WIP changes so that they do not interfere with publishing ready changes'''
    current = git.currentBranch()
    ready= re.sub("^wip/", "ready/", current)
    wip = re.sub("ready/", "^wip/", current)
    rchanges = git.changes(ready, git.config("feature.target", "master"))
    wchanges = git.changes(wip, ready)

    if len(rchanges) > 0:
        print "Ready:"
        print "  * " + "\n  * ".join(rchanges)

    if len(wchanges) > 0:
        print "In progress:"
        print "  * " + "\n  * ".join(wchanges)

    if len(wchanges) == 0 and len (rchanges) == 0:
        print "no pending changes"


@command
def ready():
    '''Merge changes from the current WIP feature branch to a READY feature branch'''
    f = Feature()
    bs = git.branches()

    target = f.ready()
    branch = f.wip()

    if str(target) in bs:
        with stashed():
            with Checkout(target):
                git.merge(branch)
    else:
        git.branch(target, branch)

@command
def merge(name=None, all=False):
    '''Merge the ready commits of the current feature to the integration branch'''
    master = git.config("feature.target", "master")
    if re.match("wip/", name):
        name = re.sup("^wip/", "ready/", name)
    elif not re.match("ready/^", name):
        name = "ready/" + name

    with stashed():
        with Checkout(master):
            git.merge("--no-ff", name)
            

@command
def publish():
    '''Push the READY feature branch to the 'origin' remote (or the feature.origin config setting)'''
    branch = git.currentBranch()

    remote = git.config("feature.origin", "origin")
    target = re.sub("^wip/", "ready/", branch)

    if remote in git.remotes():
        git.push(remote, target)
    else:
        error("feature.origin not set to valid remote and remote 'origin' not found")

@command
def push(name=None):
    '''Push the WIP feature branch to the 'mine' remote (or the feature.fork config setting)'''
    branch = git.currentBranch()

    remote = git.config("feature.fork", "mine")
    target = Feature(name).wip()

    if remote in git.remotes():
        git.push("-f", remote, target)
    else:
        error("feature.fork not set to valid remote and remote 'mine' not found")

@command
def list():
    '''Show all feature branches, WIP or READY'''
    print "\n".join(map(str, features()))

@command
def done():
    '''Check out the 'master' branch (or feature.target branch)'''
    branch=git.config("feature.target", "master")

    f = Feature()
    ready()
    git.checkout(branch)
    f.wip().delete()

@command
def status():
    '''show status of all features'''
    ''' Show all feature branches that might require work'''
    masterbranch = git.config("feature.target", "master")
    mastercommit = git.commitFor(masterbranch)

    for feature in features():
        s = []
        s.append(str(feature) + ":")
        ready = feature.ready()
        wip = feature.wip()

        if ready.exists():
            b = ready
            if len(ready.changes(masterbranch)) > 0:
                s.append("{} unmerged".format(len(ready.changes(masterbranch))))

            if wip.exists():
                if len(wip.changes(b))> 0:
                    s.append("{} in progress".format(len(wip.changes(b))))
        else:
            b = masterbranch
            if wip.exists():
                if len(wip.changes(b))> 0:
                    s.append("{} in progress".format(len(wip.changes(b))))
                else:
                    s.append("not started")


        if len(s) == 1:
            s.append("done")
        else:
            print " ".join(s)

        
@command
def pending():
    ''' Show all feature branches that might require work'''
    masterbranch =git.config("feature.target", "master")
    mastercommit = git.commitFor(masterbranch)

    results = dict()
    def add(b, msg):
        m = re.match("^(wip|ready)/(.*)", b)
        b = m.group(2)
        if b not in results:
            results[b] = []
        results[b].append(msg)

    cur = git.currentBranch()

    if re.match("^(wip|ready)/",cur) and git.hasChanges():
        add(cur, "uncommitted changes")

    unmerged = filter(lambda x: "ready/" in x, linesFrom("git branch --no-merged"))
    for b in unmerged:
        add(b, "not in current branch")

    branches = git.branches()

    wip = filter(lambda x: re.match("^wip/",x), branches)
    ready = filter(lambda x: re.match("^ready/",x), branches)

    branches = git.branches()
    for branch in wip:
        target = re.sub("^wip/", "ready/", branch)
        if target in branches:
            changes = git.changes(branch, target)
            if len(changes) > 0:
                add(branch, "{} change(s) in progress".format(len(changes)))
        else:
            changes=git.changes(branch, masterbranch)
            if len(changes) > 0:
                add(branch, "no ready branch. {} change(s) in progress".format(len(changes)))

    for branch in ready:
        changes = git.changes(branch, masterbranch)
        if changes:
            add(branch, "{} change(s) ready to merge to {}".format(len(changes), masterbranch))


    for k in sorted(results):
        print "{}: {}".format(k, ", ".join(results[k]))
        
@command
def info():
    print "integration branch is {}".format(git.config("feature.target", "master"))
    print "publish ready features to {}".format(git.config("feature.origin", "origin"))
    print "push work in progress to {}".format(git.config("feature.fork", "mine"))

@command
@quiet
def unmerged():
    ''' Show all feature branches that have not yet been merged to the current branch'''
    integration = git.config("feature.target", "master")

    with Checkout(integration, quiet=True):
        print "\n".join(str(x.ready()) for x in features("--no-merged") if x.ready().exists())

@command
@quiet
def merged():
    ''' Show all feature branches that a READY and *have* been merged '''

    ''' Show all feature branches that have not yet been merged to the current branch'''
    integration = git.config("feature.target", "master")

    with Checkout(integration, quiet=True):
        print "\n".join(str(x.ready()) for x in features("--merged") if x.ready().exists())


@command
def wip():
    '''show work in progress branches that have not yet been merged to ready'''
    for f in features():
        if f.wip().exists():
            if f.ready().exists():
                if f.wip().hasChanges(f.ready()):
                    print f
            else:
                print f


######################################################################
# and main...

def runcommand(args):
    ''' Run the UI command with appropriate arguments by introspection'''
    func = args.func
    info = inspect.getargspec(func)
    d = dict()
    for a in info.args:
        d[a]=args.__dict__[a]

    func(**d)

# A bit of an ugly hack
Verbose=True

def main():
    parser = argparse.ArgumentParser(description="Implement git feature branches")

    subparser  = parser.add_subparsers()

    # Dynamically add arguments for commands

    # TODO:  interpret a varargs as "all the rest of the arguments".  E.g. see push --name
    for f in Commands:
        subp = subparser.add_parser(f.__name__, help=f.__doc__)
        subp.set_defaults(func=f)
        args, varargs, keywords, defaults = inspect.getargspec(f)
        for i, a in enumerate(args):
            di = i + len(defaults)- len(args)
            if not defaults is None and di >-1:
                defaultValue = defaults[di]
                if defaultValue is True or defaultValue is False:
                    subp.add_argument("-" + a, default=defaultValue, action='store_const', const=True)
                else:
                    subp.add_argument("-" + a, default=defaultValue)
            else:
                subp.add_argument(a)

    args = parser.parse_args()

    runcommand(args)


if __name__ == "__main__":
    main()
